## go_atomic

因为不同的 CPU 架构甚至不同的版本提供的原子操作的指令是不同的，所以，要用一种编程语言实现支持不同架构的原子操作是相当有难度的

### 简单例子

```go
const x int64 = 1 + 1<<33

func main() {
    var i = x
    _ = i
}
```

如果使用GOARCH=386的机子，则`_ = i`被拆成两个指令，分别操作低32位和高32为(使用 GOARCH=386 go tool compile -N -l test.go; GOARCH=386 go tool objdump -gnu test.o 反编译)

如果使用GOARCH = amd64架构去编译，其实是一条指令

### 使用场景
1. 不涉及到对资源复杂的竞争逻辑，只是会并发地读写某个标志，这类场景就适合使用 atomic 的原子操作
2. 使用 atomic 实现自己定义的基本并发原语

### lock-free

[lock-free](https://learn.microsoft.com/zh-cn/windows/win32/dxtecharts/lockless-programming)

### 注意

atomic 操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法。

### 基本操作

**Add**

Add 方法就是给第一个参数地址中的值增加一个 delta 值

对于有符号的整数来说，delta 可以是一个负数，相当于减去一个值。对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？毕竟，atomic 并没有提供单独的减法操作。

我来跟你说一种方法。你可以利用计算机补码的规则，把减法变成加法。

以 uint32 类型为例：

```go
AddUint32(&x, ^uint32(c-1)).
```

如果是对 uint64 的值进行操作，那么，就把上面的代码中的 uint32 替换成 uint64。尤其是减 1 这种特殊的操作，我们可以简化为：

```go
AddUint32(&x, ^uint32(0))
```

**CAS(CompareAndSwap)**

```go
func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
```

**Load**

Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是一个原子操作。

**Store**

Store 方法会把一个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Store 是一个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了一半的值。

**Value**类型

它可以原子地存取对象类型，但也只能存取

### 内存对齐

在现在的系统中，write 的地址基本上都是对齐的（aligned）。 比如，32 位的操作系统、CPU 以及编译器，write 的地址总是 4 的倍数，64 位的系统总是 8 的倍数（还记得 WaitGroup 针对 64 位系统和 32 位系统对 state1 的字段不同的处理吗）。对齐地址的写，不会导致其他人看到只写了一半的数据，因为它通过一个指令就可以实现对地址的操作。如果地址不是对齐的话，那么，处理器就需要分成两个指令去处理，如果执行了一个指令，其它人就会看到更新了一半的错误的数据，这被称做撕裂写（torn write） 。所以，你可以认为赋值操作是一个原子操作，这个“原子操作”可以认为是保证数据的完整性。

但是，对于现代的多处理多核的系统来说，由于 cache、指令重排，可见性等问题，我们对原子操作的意义有了更多的追求。在多核系统中，一个核对地址的值的更改，在更新到主内存中之前，是在多级缓存中存放的。这时，多个核看到的数据可能是不一样的，其它的核可能还没有看到更新的数据，还在使用旧的数据

多处理器多核心系统为了处理这类问题，使用了一种叫做内存屏障（memory fence 或 memory barrier）的方式。一个写内存屏障会告诉处理器，必须要等到它管道中的未完成的操作（特别是写操作）都被刷新到内存中，再进行操作。此操作还会让相关的处理器的 CPU 缓存失效，以便让它们从主存中拉取最新的值。

atomic 包提供的方法会提供内存屏障的功能，所以，atomic 不仅仅可以保证赋值的数据完整性，还能保证数据的可见性，一旦一个核更新了该地址的值，其它处理器总是能读取到它的最新值。但是，需要注意的是，因为需要处理器之间保证数据的一致性，atomic 的操作也是会降低性能的。












