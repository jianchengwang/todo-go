package main

import "fmt"

/**
Go 值传递的机制让数组在各个函数间传递起来比较“笨重”，开销较大，且开销随数组长度的增加而增加。
为了解决这个问题，Go 引入了切片这一不定长同构数据类型。切片可以看成是数组的“描述符”，为数组打开了一个访问与修改的“窗口”。
切片在 Go 运行时中被实现为一个“三元组（array, len, cap）”，其中的 array 是指向底层数组的指针，真正的数据都存储在这个底层数组中；len 表示切片的长度；
而 cap 则是切片底层数组的容量。我们可以为一个数组建立多个切片，
这些切片由于共享同一个底层数组，因此我们通过任一个切片对数组的修改都会反映到其他切片中。切片是不定长同构复合类型，这个不定长体现在 Go 运行时对它提供的动态扩容的支撑。
当切片的 cap 值与 len 值相等时，如果再向切片追加数据，Go 运行时会自动对切片的底层数组进行扩容，追加数据的操作不会失败。
在大多数场合，我们都会使用切片以替代数组，原因之一是切片作为数组“描述符”的轻量性，无论它绑定的底层数组有多大，传递这个切片花费的开销都是恒定可控的；
另外一个原因是切片相较于数组指针也是有优势的，切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等。
而且，指针本身在 Go 语言中的功能也受到的限制，比如不支持指针算术运算。
*/

func main() {
	// 切片声明仅仅是少了一个“长度”属性。切片类似数组的描述符，类似文件描述符基于文件
	var nums = []int{1, 2, 3, 4, 5, 6}
	fmt.Println(len(nums)) // 6
	fmt.Println(cap(nums))
	nums = append(nums, 7) // 切片变为[1 2 3 4 5 6 7]
	fmt.Println(len(nums)) // 6
	fmt.Println(cap(nums)) // 7

	//s1 := make([]byte, 6, 10) // 其中10为cap值，即底层数组长度，6为切片的初始长度
	//s2 := make([]byte, 6)     // cap = len = 6
}
